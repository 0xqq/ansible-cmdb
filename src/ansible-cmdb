#!/usr/bin/env python

# ansible_cmd
#
# Generate host overview (configuration management database) from ansible fact
# gathering output.
#
# Usage:
#
#   $ ansible -m setup --tree out all
#   $ ansible-cmdb out > cmdb.html
# 

import optparse
import sys, os
import shlex
import re
import json, mako
from mako.template import Template
import pprint

class Ansible(object):
    def __init__(self, fact_dirs, hosts_file=None):
        self.fact_dirs = fact_dirs
        self.hosts_file = hosts_file
        self.hosts = {}
        for fact_dir in self.fact_dirs:
            self.parse_fact_dir(fact_dir)
        if self.hosts_file is not None:
            self.parse_hosts(self.hosts_file)

    def parse_fact_dir(self, fact_dir):
        """
        Walk through a directory of JSON files and extract information from
        them. This is used for both the Ansible fact gathering (setup module)
        output and custom variables.
        """
        flist = []
        for (dirpath, dirnames, filenames) in os.walk(fact_dir):
            flist.extend(filenames)
            break

        for fname in flist:
            hostname = fname

            fd = open(os.path.join(fact_dir, fname), 'r')
            s = fd.readlines()
            fd.close()
            try:
                x = json.loads(''.join(s))
                self.update_host(hostname, x)
                self.update_host(hostname, {'name': hostname})
            except ValueError as e:
                # Ignore non-JSON files (and bonus errors)
                sys.stderr.write("Error parsing: %s: %s\n" % (fname, e))

    def parse_hosts(self, hosts_file):
        """
        Parse an ansible hosts file and extract information about each host
        from it, including custom variables. Supports hostname expansions (e.g.
        foo[01:10].bar.com).
        """
        cur_group = []
        for line in file(options.inventory, 'r'):
            line = line.strip()
            if line.startswith('#') or not line:
                # Ignore comments and empty lines
                continue
            elif line.startswith('['):
                # Store current group we're in
                m = re.match("\[(.*)\]", line)
                cur_group = m.groups()[0]
            else:
                hostname, key_values = self._parse_hosts_line(line)
                expanded_hostnames = self._expand_hostdef(hostname)
                for hostname in expanded_hostnames:
                    self.update_host(hostname, key_values)
                    self.update_host(hostname, {'groups': cur_group})

    def _parse_hosts_line(self, line):
        """
        Parse a line with a host definition from an Ansible hosts definition
        file. Split up the line using shell-like syntax and extract the
        hostname and variables.
        """
        tokens = shlex.split(line.strip())
        hostname = tokens.pop(0)
        key_values = {}
        for token in tokens:
            if token == '#':
                # End parsing if we encounter a comment, which lasts
                # until the end of the line.
                break
            else:
                k, v = token.split('=', 1)
                key = k.strip()
                key_values[key] = v.strip()

        return (hostname, {'hostvars': key_values})

    def _expand_hostdef(self, hostdef):
        """
        Expand a host definition (e.g. "foo[001:010].bar.com") into seperate
        hostnames. Supports zero-padding, numbered ranges and alphabetical
        ranges. Multiple patterns in a host defnition are also supported.
        Returns a list of the fully expanded hostnames. Ports are also removed
        from hostnames as a bonus (e.g. "foo.bar.com:8022" -> "foo.bar.com")
        """
        hosts_todo = [hostdef]
        hosts_done = []

        # Keep going through the todo list of hosts until they no longer have a
        # pattern in them. We only handle the first pattern found in the host for
        # each iteration of the while loop. If more patterns are present, the
        # partially expanded host(s) gets added back to the todo list.
        while hosts_todo:
            host = hosts_todo.pop(0)
            if not '[' in host:
                hosts_done.append(host)
                continue

            # Extract the head, first pattern and tail. E.g. foo[0:3].bar.com ->
            # head="foo", pattern="0:3", tail=".bar.com"
            head, rest = host.split('[', 1)
            pattern, tail = rest.split(']', 1)
            start, end = pattern.split(':')
            fill = False
            if start.startswith('0') and len(start) > 0:
                fill = len(start)

            try:
                for i in range(int(start), int(end) + 1):
                    if fill:
                        range_nr = str(i).zfill(fill)
                    else:
                        range_nr = i
                    new_host = '{0}{1}{2}'.format(head, range_nr, tail)
                    if '[' in new_host:
                        hosts_todo.append(new_host)
                    else:
                        hosts_done.append(new_host)
            except ValueError:
                for i in range(ord(start), ord(end) + 1):
                    new_host = '{0}{1}{2}'.format(head, chr(i), tail)
                    if '[' in new_host:
                        hosts_todo.append(new_host)
                    else:
                        hosts_done.append(new_host)

        # Strip port numbers off and return
        return [host_name.split(':')[0] for host_name in hosts_done]

    def update_host(self, hostname, key_values):
        """
        Update a hosts information. This is called by various collectors such
        as the ansible setup module output and the hosts parser to add
        informatio to a host. It does some deep inspection to make sure nested
        information can be updated.
        """
        host_info = self.hosts.get(hostname, {'name': hostname})
        groups = host_info.get('groups', [])
        if 'groups' in key_values:
            groups.append(key_values.pop('groups'))
        hostvars = host_info.get('hostvars', {})
        if 'hostvars' in key_values:
            hostvars.update(key_values['hostvars'])
        host_info.update(key_values)
        host_info['groups'] = groups
        host_info['hostvars'] = hostvars
        self.hosts[hostname] = host_info


parser = optparse.OptionParser()
parser.set_usage(sys.argv[0] + " [option] <dir> > output.html")
parser.add_option("-t", "--template", dest="template", action="store", default='html_fancy', help="Template to use. Default is 'html_fancy'")
parser.add_option("-i", "--inventory", dest="inventory", action="store", default=None, help="Inventory hosts file to read extra info from")
(options, args) = parser.parse_args()

if len(args) < 1:
    parser.print_usage()
    sys.stderr.write("The <dir> argument is mandatory\n")
    sys.exit(1)

ansible = Ansible(args, options.inventory)

# Render a template with the gathered host info
tpl_path = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), '%s.tpl' % (options.template))
if not os.path.isfile(tpl_path):
    sys.stderr.write("Template not found: {0}\n".format(tpl_path))
    sys.exit(1)

mytemplate = Template(filename=tpl_path)
sys.stdout.write(mytemplate.render(hosts=ansible.hosts))
